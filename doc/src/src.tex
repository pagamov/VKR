\section{Введение}

Факторизация чисел является вычислительно сложной задачей, до сих пор не известно, существует ли не квантовый алгоритм, такой как алгоритм Шора, работающий за полиномиальное время, однако и доказательства того, что такого алгоритма нет, не существует, что дает надежды.

В данном документе будет изложена теория и информация, которая потребовалась для реализации алгоритм Померанца, он же метод квадратичного решета, он же Quadratic sieve algorithm или QS.

\subsection{Факторизация Ферма}

Метод факторизации Ферма заключается в простой идее нахождения двух чисел $x$ и $y$, такие, что:
$$
x^2 - y^2 = n
$$
$$
(x-y)*(x+y) = n
$$
Но на практике данный способ нахождения факторов очень долгий. Нам стоит заметить тут очень важную особенность:
$$
x^2 - y^2 = n \,(mod\,\,n)
$$
$$
x^2 - y^2 = 0 \,(mod\,\,n)
$$
$$
x^2 = y^2 \,(mod\,\,n)
$$
Отсюда следует простой факт, что мы теперь не обязаны искать конкретные значения $x$ и $y$, модульная арифметика позволяет нам их создать, они могут быть разными, в том числе и очень огромными, во много превышающими наше число $n$.
Далее найдя такие числа, используя алгоритм Эйлера для нахождения наибольшего общего делителя мы находим наше решение:
$$
min(GCD(x-y,n),GCD(x+y,n))
$$
И если результат отличен от нуля, то данное число будет являться фактором числа $n$, второе число ищется простым делением.

\subsection{Гладкие числа}

Для заданного числа $B$, гладким числом называется такое, что представимо в виде произведения всех простых чисел $\leq B$ в каких то степенях, к примеру:

Для числа $B=7$ множество простых состоит из $\{2,3,5,7\}$ и гладким считается к примеру 360, так как оно представимо как $2^3*3^2*5^1*7^0$ c соответсвующим ему вектором разложения в факторной базе $\{3,2,1,0\}$

Далее сразу будем рассматривать пример с последующим объяснением наших действий. К примеру мы факторизуем число 539873 с факторной базой до числа 19

Работая по модулю получаем некоторые числа:

$$
735^2 \equiv 352 \equiv 2^5 * 11
$$
$$
750^2 \equiv 22627 \equiv 11^3 * 17
$$
$$
783^2 \equiv 73216 \equiv 2^9 * 11 * 13
$$
$$
801^2 \equiv 101728 \equiv 2^5 * 11 * 17^2
$$

\subsection{Решение системы уравнений}

Мы не знаем когда остановиться точно, оценки дают, что нам необходимо найти гладких чисел на 1 больше, чем размер факторной базы, но для примера думаю нам хватит, вдруг мы найдем ответ раньше.

Получив данные гладкие числа, нам надо понять, из каких чисел составлять наши финальные $x$ и $y$. Решим систему уравнений

$$
352^{x_1} \equiv 2^{5x_1} * 11^{x_1}
$$
$$
22627^{x_2} \equiv 11^{3x_2} * 17^{x_2}
$$
$$
73216^{x_3} \equiv 2^{9x_3} * 11^{x_3} * 13^{x_3}
$$
$$
101728^{x_4} \equiv 2^{5x_4} * 11^{x_4} * 17^{2x_4}
$$

$$
352^{x_1}22627^{x_2}73216^{x_3}101728^{x_4} \equiv 
2^{5x_1+9x_3+5x_4} 11^{x_1+3x_2+x_3+x_4} 13^{x_3} 17^{x_2+2x_4}
$$

Чтобы продукт был квадратом, степени должны быть четные, значит работаем mod 2

Решаем систему линейных уравнений относительно степеней по модулю 2

$$
5x_1+9x_3+5x_4 \equiv 0
$$
$$
x_1+3x_2+x_3+x_4 \equiv 0
$$
$$
x_3 \equiv 0
$$
$$
x_2+2x_4 \equiv 0
$$

Откуда решенем является

$$
x_1 = 1, x_2 = 0, x_3 = 0, x_4 = 1
$$

Следовательно из равенства Ферма

$$
735^2*801^2 \equiv 2^10 * 11^2 * 17^2
$$

$$
(735*801)^2 \equiv (2^5 * 11 * 17)^2
$$

Далее переносим в левую часть получаем
$$
(735*801)^2 - (2^5 * 11 * 17)^2 \equiv 0
$$
$$
(735*801 - 2^5 * 11 * 17) * (735*801 + 2^5 * 11 * 17) \equiv 0
$$

Откуда применяя алгоритм $GCD(x-y,n), GCD(x+y,n)$ получаем \underline{1947} и \underline{277}, это и есть факторы нашего числа $n$

В следующей главе я покажу части реализации и покажу какие аспекты и какие оптимизации мы с командой использовали, чтобы факторизовать числа в 40 десятичных знаков меньше чем за час.

\pagebreak

\section{Реализация}

Первый этап Quadratic sieve algorithm - набор факторной базы.

\subsection{Факторная база}

\subsubsection{Решето Эратосфена}

Как оказалось, нельзя просто сказать программе посчитать все простые числа до B, для разложения конкретно больших чисел требуется внушительная факторная база, в дальнейшем мы из нее все равно отсеем чуть ли не половину, но об этом чуть позже. 

Решето это быстрый способ найти все простые числа до конкретного значения. Работает быстро, изучается еще в школе, далее код.

\begin{lstlisting}
def eratosthenes(n):
    numbers = list(range(2, n + 1))
    for number in numbers:
        if number != 0:
            for candidate in range(2 * number, n+1, number):
                numbers[candidate-2] = 0
    return list(filter(lambda x: x != 0, numbers))
\end{lstlisting}

\subsubsection{Символ Лежандра}

Являясь частным случаем числа Якоби, позволяет понять разрешимо ли уравнение $x^2 \equiv a \,\,(mod \,\, p)$ и дает ответ либо $ \left( \dfrac{a}{p} \right)$ =  0 (если a делится на p),$ \left( \dfrac{a}{p} \right)$ =  1 (если a является квадратичным вычетом по модулю p), а также $ \left( \dfrac{a}{p} \right)$ = -1 (если не является).

\subsubsection{Алгоритм Тонелли — Шенкса}

Символ Лежандра, ввиду своей легкости выполнения просто является проверкой, стоит ли брать то или иное простое число в факторную базу, как только число прошло проверку, осталось найти решения уравнения $x^2 \equiv a \,\,(mod \,\, p)$ для каждого простого числа $p$

\begin{lstlisting}
def tonelli(n, p):
    assert legendre(n, p) == 1, "not a square (mod p)"
    q = p - 1
    s = 0
    while q % 2 == 0:
        q //= 2
        s += 1
    if s == 1:
        return pow(n, (p + 1) // 4, p)
    for z in range(2, p):
        if p - 1 == legendre(z, p):
            break
    c = pow(z, q, p)
    r = pow(n, (q + 1) // 2, p)
    t = pow(n, q, p)
    m = s
    t2 = 0
    while (t - 1) % p != 0:
        t2 = (t * t) % p
        for i in range(1, m):
            if (t2 - 1) % p == 0:
                break
            t2 = (t2 * t2) % p
        b = pow(c, 1 << (m - i - 1), p)
        r = (r * b) % p
        c = (b * b) % p
        t = (t * c) % p
        m = i
    return r
\end{lstlisting}

Таким образом для всех простых чисел мы нашли ровно \underline{два} решения уравнения за $O(log(n)log(p))$


\subsection{Просеивание}

Составив факторную базу пользовательского размера мы начинаем брать пользовательские регионы L1 и L2 чтобы квадратически просеять в нем все числа, которые могут быть гладкими по факторной базе

\begin{lstlisting}
def smooth_region(L1, L2, q, primes):
    res0 = list(range(L1, L2))
    res1 = []
    for i in range(L1, L2):
        res1.append(q(i))
    res2 = np.zeros((len(res0), len(primes)), dtype="int8")
    s = []
    primes_skipped = 0
    for i in range(len(primes)):
        s.append([])
        for r in primes.r[i]:
            k = L1 // primes(i)
            while r + k*primes(i) >= L1:
                k -= 1
            k+=1
            if r + k*primes(i) >= L2:
                primes_skipped += 1
            s[i].append(r + k*primes(i))
    for p in range(len(primes)):
        for s_i in s[p]:
            if s_i <= L2:
                res2[s_i - L1::primes(p), p] += 1
                for i in range(s_i, L2, primes(p)):
                    res1[i - L1] //= primes(p)
                for i in range(s_i, L2, primes(p)):
                    x = i - L1
                    while res1[x] % primes(p) == 0:
                        res1[x] //= primes(p)
                        res2[x, p] += 1
    ans = []
    for i in range(len(res1)):
        if abs(res1[i]) == 1:
            ans.append([res0[i],q(res0[i]),res2[i]])
    return ans
\end{lstlisting} 

Основная идея в том, чтобы не идти итеративно по числам и проверять на гладкость, мы формируем массив точек и значений генерирующей функции в данной точке, далее используюя найденные на этапе генерирования факторной базы корни уравнения, с помощью алгоритма Тонелли — Шенкса, мы можем исключить вовсе деление на те числа, которые заведомо не делятся ни на какое простое число из факторной базы. Результатом выполнения алгоритма будет массив степеней полученных гладких чисел.


\subsection{Решение матричного уравнения}

Каждое найденное число добавляется в специальный класс Matrix\_Solver, чтобы при нахождении критического объема гладких чисел, запустить процедуру решения матричного уравнения

\begin{lstlisting}

def solve(self):
    self.gaus = []
    self.gaus = self.matrix % 2
    if len(self.gaus[0]) == 0:
        return None
    lineal_rows =  np.zeros((len(self.gaus[0]), len(self.gaus[0])), 'int8')
    np.fill_diagonal(lineal_rows, True)
    banned_rows = set()
    banned_numbers = set()
    for y in range(len(self.gaus[0])):
        x = -1
        for i in range(len(self.gaus)):
            if self.gaus[i, y] == 1 and i not in banned_rows:
                x = i
                banned_rows.add(i)
                banned_numbers.add(y)
                break
        if x >= 0:
            for j in range(len(self.gaus[0])):
                if j != y and self.gaus[x][j] == 1 and j not in banned_numbers:
                    lineal_rows[:,j] ^= lineal_rows[:,y]
                    self.gaus[:,j] ^= self.gaus[:,y]
    ans = []
    for y in range(len(self.gaus[0])):
        if y not in banned_numbers:
            flag = True
            for x in range(len(self.gaus)):
                if self.gaus[x][y] == 1:
                    flag = False
                    break
            if flag:
                b = []
                for i in range(len(lineal_rows)):
                    if lineal_rows[i][y]:
                        b.append(i)
                ans.append(b)
    return ans
\end{lstlisting}

Результатом решения, которое выполняется на разряженной матрице по модулю 2 за $O(n^2)$ будет массив сетов, которые говорят, совокупность каких гладких чисел и их точек будет являться полным квадратом.

Далее алгоритм итеративно берет решения, соствляет $x$ и $y$, подставляет в GCD, получает либо 1, либо ответ. На этом этапы квадратичного решета заканчиваются.

\section{Демонстрация}

\subsection{Первое число}

Рассмотрим как работает код на различных числах.

Для числа 10848981839 возьмем факторную базу равную 30000

\begin{alltt}
B 30000
99.97 %
primes done in time: 0.053 sec
primes len 1633
\end{alltt}

После этапа формирования базы наступает этап просеивания.

\begin{alltt}
Table creation in time: 0.0817 sec
S search completed in time: 0.0061 sec
Prime devision completed in time: 0.2864 sec
Ans creation in time: 0.023 sec
7233 in [0...100000] in time: 0.3972 sec primes skipped: 0.0 %

Table creation in time: 0.0729 sec
S search completed in time: 0.0063 sec
Prime devision completed in time: 0.2808 sec
Ans creation in time: 0.024 sec
7742 in [-100000...0] in time: 0.3841 sec primes skipped: 0.0 %

Total number of smooth numberes: 14975
\end{alltt}

А потом этап решения матричного уравнения.

\begin{alltt}
form matrix 1633 x 1633 in time: 0.0147 sec
mult matrix 99.94 %
done operations 5.5364 sec
form ans 1.397 sec
got 525 ans
Solve Done

ans: 103591 104729
time: 7.8472 sec
\end{alltt}

Решение найдено быстро. Попробуем усложнить, взяв число побольше

\subsection{Второе число}

Возьмем число 21732355031876974040501222359 состоящее из 29 десятичных знаков.

\begin{alltt}
B 300000
100.0 %
primes done in time: 0.4593 sec
primes len 13020
\end{alltt}

\begin{alltt}
Table creation in time: 0.08 sec
S search completed in time: 0.0438 sec
Prime devision completed in time: 0.6689 sec
Ans creation in time: 0.0167 sec
913 in [0...100000] in time: 0.8096 sec primes skipped: 27.88 %
\end{alltt}

и так дальше продолжатеся до тех пор пока не найдутся числа.

\begin{alltt}
Table creation in time: 0.0803 sec
S search completed in time: 0.0417 sec
Prime devision completed in time: 0.8507 sec
Ans creation in time: 0.0168 sec
490 in [-1100000...-1000000] in time: 0.9897 sec primes skipped: 27.84 %
\end{alltt}

\begin{alltt}
form matrix 13020 x 13020 in time: 0.9042 sec
mult matrix 99.99 %
done operations 2610.7121 sec
form ans 76.1091 sec
got 3183 ans
Solve Done

ans: 21732382677641 999998727899999
time: 2714.5045 sec
\end{alltt}

Что уже занимает внушительные 45 минут.

\subsection{Третье число}

Число 1743330609104359794310832380648502630502518659 состоящее из 45 знаков

\begin{alltt}
B 200000
99.99 %
primes done in time: 1.3334 sec
primes len 9002
\end{alltt}

Выбор такого малого B связан с тем, что лучше пожертвовать плотностью гладких чисел и пройти больше регионов, нежели решать огромную матрицу.

\begin{alltt}
Table creation in time: 0.1237 sec
S search completed in time: 0.0289 sec
Prime devision completed in time: 1.1639 sec
Ans creation in time: 0.0209 sec
17 in [0...200000] in time: 1.3384 sec primes skipped: 0.0 %
\end{alltt}

17 чисел на таком интервале, неплохо, но в дальнейшем плотность падает и мы еле-еле получаем хотя бы 1-2 числа на интервале.

\begin{alltt}
Table creation in time: 0.1406 sec
S search completed in time: 0.0339 sec
Prime devision completed in time: 1.2786 sec
Ans creation in time: 0.0229 sec
2 in [306400000...306600000] in time: 1.479 sec primes skipped: 0.0 %

Table creation in time: 0.1825 sec
S search completed in time: 0.0369 sec
Prime devision completed in time: 1.4481 sec
Ans creation in time: 0.0249 sec
1 in [-306600000...-306400000] in time: 1.6965 sec primes skipped: 0.0 %
\end{alltt}

Нам пришлось уйти очень далеко, чтобы найти необходимый минимум.

\begin{alltt}
form matrix 9002 x 9002 in time: 0.2588 sec
mult matrix 99.99 %
done operations 1719.993 sec
form ans 11.0345 sec
got 750 ans
Solve Done

ans: 3331113965338635107 523347633027360537213687137
time: 6581.8423 sec
\end{alltt}

Что приблизительно 2 часа на число с 45 знаками.










\section{Дополнение}

\subsection{Возможные улучшения}

\subsubsection{Точная оценка B}

Во-первых оценка B задается пользователем, что уже плохо, ведь пользователь врятли знает как работает программа и что вообще от него требуется кроме как ввести свое число, которое он хочет факторизовать.

Читая литературу по алгоритму, увидел такую оценку: 
$$B = \exp{\sqrt{log(n)*log(log(n))}}$$
Некоторые говорят, что надо вставить двойку под корень, получается 
$$B = \exp{\sqrt{2*log(n)*log(log(n))}}$$
Одно верно, данная оценка слишком избытычна для факторизации каких либо чисел. К примеру при числе в 11 знаков такая оценка даст размер факторной базы примерно 5 тысяч. Что является не таким большим числом, в моем случае для такого числа берется размер факторной базы около 3 тысяч. Но для числа из 45 знаков, такая оценка дает 3.5 \underline{миллиарда}. Так как для гарантированного решения матричного уравнения нам требуется как минимум на одно гладкое число больше чем размер факторной базы, решение такой матрицы займет очень долго времени, как и само время просеивания. Это мы еще не берем размер оперативной памяти, требуемый для хранения составляющих процесса, такие как разряженная матрица и списки с гладкими числами.

\subsubsection{Мультипроцессинг}

Python поддерживает вычисления на многих процессорах, таким образом, написанный выше алгоритм просеивания по интервалу можно распараллелить. Что дает нам большой выигрыш в скорости нахождения гладких чисел.



\section{Заключение}

Я познакомился с удивительным миром сложных алгоритмов и тяжелой математики. Я бы хотел попробывать переписать данный код на более быстрый язык, например C++. Многое осталось за кадром в данном отчете, много о чем можно спорить и рассуждать. Признаю, мне не хватило знаний и терпения для разработки самого быстрого на сегодняшний день алгоритма факторизации - general number field sieve он же GNFS. Но возможно в будущем я вернусь к его реализации.

\pagebreak







